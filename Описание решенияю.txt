Технические задачи

Improvement: Добавить иконку мячика, если футболист забил гол

Я решила добавить новое числовое свойство у класса Player которое будет хранить количество забитых игроком голов.
Этому свойству конструкторе задается значение 0
    Также добавила функцию у игрока madeGoal(), которая увеличивает количество голов на один.
Функция вызывается у игрока в методе processLogs() сервиса MatchBuilder в случае события 'goal'.

    В шаблоне twig добавила рендеринг иконки мяча в цикле если свойство goal у игрока больше ноля.
Иконка мяча выводиться столько раз сколько футболист забил гол.


Improvement: Добавить отображение желтых и красных карточек напротив футболистов, которые получили карточки

    Я добавила классу Player свойства $yellowCard и $redCard типа bool, также методы
gotYellowCard() и gotRedCard(). Во время создания игрока в конструкторе свойствам $yellowCard и $redCard
присваивается значение false.
    В методе processLogs() сервиса MatchBuilder я добавила дополнительные условия case 'yellowCard' и case 'redCard'.

    В случае события 'redCard' у у игрока вызывается метод gotRedCard() в который передается текущая минута $minute.
Этот метод обновляет свойтво redCard на true и вызывает метод goToBench() с переданой текущей минутой,
поскольку красная карта означает дисквалификацию игрока.
    В случае события 'yellowCard' у игрока получившего карточку вызывается метод gotYellowCard(), который
сначала проверяет текущее состояние свойства yellowCard с помощью оператора if. Если свойство yellowCard
уже является правдой (то есть у игрока уже есть одна желтая карточка и сейчас он получает вторую, которая в футболе
приравнивается к получению красной карты) выполняется первое условие в  котором у игрока  вызывается метод gotRedCard().
В противном случае(если свойство yellowCard равняется false и игрок получает первую желтую карточку)  свойству
yellowCard присваивается значение true.

    В twig шаблоне после вывода имени игрока я добавила проверку свойства redCard, если оно true выводиться иконка
красной карточки, если же нет проверяется свойство yellowCard и если оно правдиво выводится иконка желтой карты.


Feature: Добавить таблицу с общим временем, проведенным на поле, для каждой позиции (нападающие, защитники и т.д.),
а не только для каждого игрока

    Я добавила классу Team константы по имени каждой позиции в футболе. Константы равняются коду position как представлено
в json файле - исходнике для игроков. Также добавила константу POSITIONS из массива названий позиций на русском языке и
соответствующим им константам с кодом позиции.
    Еще добавила новое свойство в виде массива  positionInfo, который создается динамически в конструкторе класса на основании
константы POSITIONS. Массив содержит в себе  массивы с информацией для каждой позиции, ключом является код позиции
(то как указаны позиции в описании игрока в источнике json), в значении хранятся название на русском
(чтобы можно было выводить для пользователя в таблице) и время. Времени присваеваеться значение 0. Классу Team также
 добавлен новый метод updatePositionTime(). В сервисе MatchBuilder добавлен новый метод savePositionTimes()

    После окончания матча в методе processLogs() сервиса MatchBuilder (то есть когда событие равно finishPeriod и период равен 2)
после того как вызван метод goToBenchAllPlayers() вызывается метод savePositionTimes() сервиса MatchBuilder ,который
получает на входе команду. Для каждого игрока команды проверяется время, и если оно больше ноля, вызывается метод
updatePositionTime() у класса Team в который передается позиция игрока и время проведенное им на поле.
Метод updatePositionTime() добавляет полученное время ко времени нужной позиции.

Во время рендера в шаблоне twig после таблицы с информацией о игроках команды я добавила таблицу с названиями позиции
и общим количеством времени проведенным на поле. В этой таблице в цикле отображаются все значения массива positionInfo.

Я вынесла коды позиций и названия в отдельные константы на тот случай если что-то  изменится
(посредник поменяет формат сохранения позиций для игроков  или поменяется посредник у которого для позиций
будут использоваться скажем полные названия) код достаточно будет можно будет изменить в одном месте,
просто обновив значение констант. Также если вдруг окажется что скажем для вратаря подсчитывать общее время не нужно,
можно просто удалить его из массива константы POSITIONS.

Для расчета общего времени я решила что лучше всего будет пройтись по массиву игроков после окончания игры и добавить
время каждого игрока к общему времени его позиции. Время решила что лучше всего хранить в свойствах команды вместе
с названием позиции, чтобы можно было легко динамически менять название
Сначала хотела отфильтровать массив игроков по позиции и к полученному отфильтрованному  массиву применить метод reduce,
но решила что лучше  пройтись по массиву игроков один раз, чем применять array_filter к массиву игроков каждый раз когда
нужно подсчитать общее время позиции. Логически(не тестировала на практике) там должно сохранятся немного времени.

Bug: Исправить ошибку с подсчетом времени, проведенном на поле

    Когда игроки отправляются на поле, (событие start Period , где period равен 1), задается время inMinute для игрока.
Поскольку в начале игры когда все игроки отправаляются на поле минута равна 1, подсчет минуты в конце игры всегда
становится меньше на 1  чем время  реально проведенное игроком на поле. Поэтому максимальное время равнялось 95 минутам.
Поскольку outMinute обновляется на последней минуте и равно последней минуте(в нашем случае 96) то время рассчитывалось
всегда на 1 минуту меньше( в нашем примере outTime(96) - inTime(1) = 95 )

    Мне показалось лучшим решением изменить inTime на 0 поэтому вместо того чтобы передавать текущую минуту в метод goToPlay сервиса
MatchBuilder вторым аргументом передается 0. На мой взгляд так наиболее очевидно что происходит, поскольку если скажем
начать добавлять или отнимать единицу в каком то другом месте можно не сразу понять почему происходит это сложение или вычитание.

